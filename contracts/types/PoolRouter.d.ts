/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
  BaseContract,
  ContractTransaction,
  Overrides,
  CallOverrides,
} from 'ethers';
import { BytesLike } from '@ethersproject/bytes';
import { Listener, Provider } from '@ethersproject/providers';
import { FunctionFragment, EventFragment, Result } from '@ethersproject/abi';
import { TypedEventFilter, TypedEvent, TypedListener } from './commons';

interface PoolRouterInterface extends ethers.utils.Interface {
  functions: {
    'LIQ_FEE_DECIMALS()': FunctionFragment;
    'MAX_OUT_RATIO()': FunctionFragment;
    'PROTOCOL_FEE_DECIMALS()': FunctionFragment;
    'collectFeesToDAO(address)': FunctionFragment;
    'deposit(address,uint256,uint256,uint256)': FunctionFragment;
    'depositAll(uint256,uint256[],uint256)': FunctionFragment;
    'getPoolTokens()': FunctionFragment;
    'getFoldAmountInSingle(address,uint256,uint256)': FunctionFragment;
    'getFoldAmountOutSingle(address,uint256,uint256)': FunctionFragment;
    'getTokenAmountOutSingle(address,uint256,uint256)': FunctionFragment;
    'getTokenWeights()': FunctionFragment;
    'getTokensAmountIn(uint256,uint256[])': FunctionFragment;
    'getTokensAmountOut(uint256,uint256[])': FunctionFragment;
    'liquidate(address,address,uint256,uint256)': FunctionFragment;
    'protocolFee()': FunctionFragment;
    'DictatorDAO()': FunctionFragment;
    'smartPool()': FunctionFragment;
    'foldToken()': FunctionFragment;
    'treasury()': FunctionFragment;
    'withdraw(address,uint256,uint256)': FunctionFragment;
    'withdrawAll(uint256,uint256[])': FunctionFragment;
    'wrappingContract()': FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: 'LIQ_FEE_DECIMALS',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'MAX_OUT_RATIO',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'PROTOCOL_FEE_DECIMALS',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'collectFeesToDAO',
    values: [string],
  ): string;
  encodeFunctionData(
    functionFragment: 'deposit',
    values: [string, BigNumberish, BigNumberish, BigNumberish],
  ): string;
  encodeFunctionData(
    functionFragment: 'depositAll',
    values: [BigNumberish, BigNumberish[], BigNumberish],
  ): string;
  encodeFunctionData(
    functionFragment: 'getPoolTokens',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'getFoldAmountInSingle',
    values: [string, BigNumberish, BigNumberish],
  ): string;
  encodeFunctionData(
    functionFragment: 'getFoldAmountOutSingle',
    values: [string, BigNumberish, BigNumberish],
  ): string;
  encodeFunctionData(
    functionFragment: 'getTokenAmountOutSingle',
    values: [string, BigNumberish, BigNumberish],
  ): string;
  encodeFunctionData(
    functionFragment: 'getTokenWeights',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'getTokensAmountIn',
    values: [BigNumberish, BigNumberish[]],
  ): string;
  encodeFunctionData(
    functionFragment: 'getTokensAmountOut',
    values: [BigNumberish, BigNumberish[]],
  ): string;
  encodeFunctionData(
    functionFragment: 'liquidate',
    values: [string, string, BigNumberish, BigNumberish],
  ): string;
  encodeFunctionData(
    functionFragment: 'protocolFee',
    values?: undefined,
  ): string;
  encodeFunctionData(
    functionFragment: 'DictatorDAO',
    values?: undefined,
  ): string;
  encodeFunctionData(functionFragment: 'smartPool', values?: undefined): string;
  encodeFunctionData(functionFragment: 'foldToken', values?: undefined): string;
  encodeFunctionData(functionFragment: 'treasury', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'withdraw',
    values: [string, BigNumberish, BigNumberish],
  ): string;
  encodeFunctionData(
    functionFragment: 'withdrawAll',
    values: [BigNumberish, BigNumberish[]],
  ): string;
  encodeFunctionData(
    functionFragment: 'wrappingContract',
    values?: undefined,
  ): string;

  decodeFunctionResult(
    functionFragment: 'LIQ_FEE_DECIMALS',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'MAX_OUT_RATIO',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'PROTOCOL_FEE_DECIMALS',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'collectFeesToDAO',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(functionFragment: 'deposit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'depositAll', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'getPoolTokens',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getFoldAmountInSingle',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getFoldAmountOutSingle',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getTokenAmountOutSingle',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getTokenWeights',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getTokensAmountIn',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'getTokensAmountOut',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(functionFragment: 'liquidate', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'protocolFee',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'DictatorDAO',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(functionFragment: 'smartPool', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'foldToken', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'treasury', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'withdraw', data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: 'withdrawAll',
    data: BytesLike,
  ): Result;
  decodeFunctionResult(
    functionFragment: 'wrappingContract',
    data: BytesLike,
  ): Result;

  events: {};
}

export class PoolRouter extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  listeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter?: TypedEventFilter<EventArgsArray, EventArgsObject>,
  ): Array<TypedListener<EventArgsArray, EventArgsObject>>;
  off<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>,
  ): this;
  on<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>,
  ): this;
  once<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>,
  ): this;
  removeListener<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>,
  ): this;
  removeAllListeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
  ): this;

  listeners(eventName?: string): Array<Listener>;
  off(eventName: string, listener: Listener): this;
  on(eventName: string, listener: Listener): this;
  once(eventName: string, listener: Listener): this;
  removeListener(eventName: string, listener: Listener): this;
  removeAllListeners(eventName?: string): this;

  queryFilter<EventArgsArray extends Array<any>, EventArgsObject>(
    event: TypedEventFilter<EventArgsArray, EventArgsObject>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TypedEvent<EventArgsArray & EventArgsObject>>>;

  interface: PoolRouterInterface;

  functions: {
    LIQ_FEE_DECIMALS(overrides?: CallOverrides): Promise<[BigNumber]>;

    MAX_OUT_RATIO(overrides?: CallOverrides): Promise<[BigNumber]>;

    PROTOCOL_FEE_DECIMALS(overrides?: CallOverrides): Promise<[BigNumber]>;

    collectFeesToDAO(
      token: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    deposit(
      tokenIn: string,
      tokenAmountIn: BigNumberish,
      minPoolAmountOut: BigNumberish,
      liquidationFee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    depositAll(
      poolAmountOut: BigNumberish,
      maxTokensAmountIn: BigNumberish[],
      liquidationFee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    getPoolTokens(overrides?: CallOverrides): Promise<[string[]]>;

    getFoldAmountInSingle(
      tokenOut: string,
      tokenAmountOut: BigNumberish,
      maxPoolAmountIn: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { poolAmountIn: BigNumber }>;

    getFoldAmountOutSingle(
      tokenIn: string,
      tokenAmountIn: BigNumberish,
      minPoolAmountOut: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { poolAmountOut: BigNumber }>;

    getTokenAmountOutSingle(
      tokenOut: string,
      poolAmountIn: BigNumberish,
      minTokenAmountOut: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<[BigNumber] & { tokenAmountOut: BigNumber }>;

    getTokenWeights(overrides?: CallOverrides): Promise<[BigNumber[]]>;

    getTokensAmountIn(
      poolAmountOut: BigNumberish,
      maxAmountsIn: BigNumberish[],
      overrides?: CallOverrides,
    ): Promise<[BigNumber[]] & { actualAmountsIn: BigNumber[] }>;

    getTokensAmountOut(
      poolAmountIn: BigNumberish,
      minAmountsOut: BigNumberish[],
      overrides?: CallOverrides,
    ): Promise<[BigNumber[]] & { actualAmountsOut: BigNumber[] }>;

    liquidate(
      liquidatedUser: string,
      tokenOut: string,
      poolAmountIn: BigNumberish,
      minAmountOut: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    protocolFee(overrides?: CallOverrides): Promise<[BigNumber]>;

    DictatorDAO(overrides?: CallOverrides): Promise<[string]>;

    smartPool(overrides?: CallOverrides): Promise<[string]>;

    foldToken(overrides?: CallOverrides): Promise<[string]>;

    treasury(overrides?: CallOverrides): Promise<[string]>;

    withdraw(
      tokenOut: string,
      poolAmountIn: BigNumberish,
      minAmountOut: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    withdrawAll(
      poolAmountIn: BigNumberish,
      minAmountsOut: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    wrappingContract(overrides?: CallOverrides): Promise<[string]>;
  };

  LIQ_FEE_DECIMALS(overrides?: CallOverrides): Promise<BigNumber>;

  MAX_OUT_RATIO(overrides?: CallOverrides): Promise<BigNumber>;

  PROTOCOL_FEE_DECIMALS(overrides?: CallOverrides): Promise<BigNumber>;

  collectFeesToDAO(
    token: string,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  deposit(
    tokenIn: string,
    tokenAmountIn: BigNumberish,
    minPoolAmountOut: BigNumberish,
    liquidationFee: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  depositAll(
    poolAmountOut: BigNumberish,
    maxTokensAmountIn: BigNumberish[],
    liquidationFee: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  getPoolTokens(overrides?: CallOverrides): Promise<string[]>;

  getFoldAmountInSingle(
    tokenOut: string,
    tokenAmountOut: BigNumberish,
    maxPoolAmountIn: BigNumberish,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  getFoldAmountOutSingle(
    tokenIn: string,
    tokenAmountIn: BigNumberish,
    minPoolAmountOut: BigNumberish,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  getTokenAmountOutSingle(
    tokenOut: string,
    poolAmountIn: BigNumberish,
    minTokenAmountOut: BigNumberish,
    overrides?: CallOverrides,
  ): Promise<BigNumber>;

  getTokenWeights(overrides?: CallOverrides): Promise<BigNumber[]>;

  getTokensAmountIn(
    poolAmountOut: BigNumberish,
    maxAmountsIn: BigNumberish[],
    overrides?: CallOverrides,
  ): Promise<BigNumber[]>;

  getTokensAmountOut(
    poolAmountIn: BigNumberish,
    minAmountsOut: BigNumberish[],
    overrides?: CallOverrides,
  ): Promise<BigNumber[]>;

  liquidate(
    liquidatedUser: string,
    tokenOut: string,
    poolAmountIn: BigNumberish,
    minAmountOut: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  protocolFee(overrides?: CallOverrides): Promise<BigNumber>;

  DictatorDAO(overrides?: CallOverrides): Promise<string>;

  smartPool(overrides?: CallOverrides): Promise<string>;

  foldToken(overrides?: CallOverrides): Promise<string>;

  treasury(overrides?: CallOverrides): Promise<string>;

  withdraw(
    tokenOut: string,
    poolAmountIn: BigNumberish,
    minAmountOut: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  withdrawAll(
    poolAmountIn: BigNumberish,
    minAmountsOut: BigNumberish[],
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  wrappingContract(overrides?: CallOverrides): Promise<string>;

  callStatic: {
    LIQ_FEE_DECIMALS(overrides?: CallOverrides): Promise<BigNumber>;

    MAX_OUT_RATIO(overrides?: CallOverrides): Promise<BigNumber>;

    PROTOCOL_FEE_DECIMALS(overrides?: CallOverrides): Promise<BigNumber>;

    collectFeesToDAO(token: string, overrides?: CallOverrides): Promise<void>;

    deposit(
      tokenIn: string,
      tokenAmountIn: BigNumberish,
      minPoolAmountOut: BigNumberish,
      liquidationFee: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<void>;

    depositAll(
      poolAmountOut: BigNumberish,
      maxTokensAmountIn: BigNumberish[],
      liquidationFee: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<void>;

    getPoolTokens(overrides?: CallOverrides): Promise<string[]>;

    getFoldAmountInSingle(
      tokenOut: string,
      tokenAmountOut: BigNumberish,
      maxPoolAmountIn: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getFoldAmountOutSingle(
      tokenIn: string,
      tokenAmountIn: BigNumberish,
      minPoolAmountOut: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getTokenAmountOutSingle(
      tokenOut: string,
      poolAmountIn: BigNumberish,
      minTokenAmountOut: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getTokenWeights(overrides?: CallOverrides): Promise<BigNumber[]>;

    getTokensAmountIn(
      poolAmountOut: BigNumberish,
      maxAmountsIn: BigNumberish[],
      overrides?: CallOverrides,
    ): Promise<BigNumber[]>;

    getTokensAmountOut(
      poolAmountIn: BigNumberish,
      minAmountsOut: BigNumberish[],
      overrides?: CallOverrides,
    ): Promise<BigNumber[]>;

    liquidate(
      liquidatedUser: string,
      tokenOut: string,
      poolAmountIn: BigNumberish,
      minAmountOut: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<void>;

    protocolFee(overrides?: CallOverrides): Promise<BigNumber>;

    DictatorDAO(overrides?: CallOverrides): Promise<string>;

    smartPool(overrides?: CallOverrides): Promise<string>;

    foldToken(overrides?: CallOverrides): Promise<string>;

    treasury(overrides?: CallOverrides): Promise<string>;

    withdraw(
      tokenOut: string,
      poolAmountIn: BigNumberish,
      minAmountOut: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<void>;

    withdrawAll(
      poolAmountIn: BigNumberish,
      minAmountsOut: BigNumberish[],
      overrides?: CallOverrides,
    ): Promise<void>;

    wrappingContract(overrides?: CallOverrides): Promise<string>;
  };

  filters: {};

  estimateGas: {
    LIQ_FEE_DECIMALS(overrides?: CallOverrides): Promise<BigNumber>;

    MAX_OUT_RATIO(overrides?: CallOverrides): Promise<BigNumber>;

    PROTOCOL_FEE_DECIMALS(overrides?: CallOverrides): Promise<BigNumber>;

    collectFeesToDAO(
      token: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    deposit(
      tokenIn: string,
      tokenAmountIn: BigNumberish,
      minPoolAmountOut: BigNumberish,
      liquidationFee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    depositAll(
      poolAmountOut: BigNumberish,
      maxTokensAmountIn: BigNumberish[],
      liquidationFee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    getPoolTokens(overrides?: CallOverrides): Promise<BigNumber>;

    getFoldAmountInSingle(
      tokenOut: string,
      tokenAmountOut: BigNumberish,
      maxPoolAmountIn: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getFoldAmountOutSingle(
      tokenIn: string,
      tokenAmountIn: BigNumberish,
      minPoolAmountOut: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getTokenAmountOutSingle(
      tokenOut: string,
      poolAmountIn: BigNumberish,
      minTokenAmountOut: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getTokenWeights(overrides?: CallOverrides): Promise<BigNumber>;

    getTokensAmountIn(
      poolAmountOut: BigNumberish,
      maxAmountsIn: BigNumberish[],
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    getTokensAmountOut(
      poolAmountIn: BigNumberish,
      minAmountsOut: BigNumberish[],
      overrides?: CallOverrides,
    ): Promise<BigNumber>;

    liquidate(
      liquidatedUser: string,
      tokenOut: string,
      poolAmountIn: BigNumberish,
      minAmountOut: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    protocolFee(overrides?: CallOverrides): Promise<BigNumber>;

    DictatorDAO(overrides?: CallOverrides): Promise<BigNumber>;

    smartPool(overrides?: CallOverrides): Promise<BigNumber>;

    foldToken(overrides?: CallOverrides): Promise<BigNumber>;

    treasury(overrides?: CallOverrides): Promise<BigNumber>;

    withdraw(
      tokenOut: string,
      poolAmountIn: BigNumberish,
      minAmountOut: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    withdrawAll(
      poolAmountIn: BigNumberish,
      minAmountsOut: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    wrappingContract(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    LIQ_FEE_DECIMALS(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    MAX_OUT_RATIO(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    PROTOCOL_FEE_DECIMALS(
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    collectFeesToDAO(
      token: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    deposit(
      tokenIn: string,
      tokenAmountIn: BigNumberish,
      minPoolAmountOut: BigNumberish,
      liquidationFee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    depositAll(
      poolAmountOut: BigNumberish,
      maxTokensAmountIn: BigNumberish[],
      liquidationFee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    getPoolTokens(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getFoldAmountInSingle(
      tokenOut: string,
      tokenAmountOut: BigNumberish,
      maxPoolAmountIn: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getFoldAmountOutSingle(
      tokenIn: string,
      tokenAmountIn: BigNumberish,
      minPoolAmountOut: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getTokenAmountOutSingle(
      tokenOut: string,
      poolAmountIn: BigNumberish,
      minTokenAmountOut: BigNumberish,
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getTokenWeights(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getTokensAmountIn(
      poolAmountOut: BigNumberish,
      maxAmountsIn: BigNumberish[],
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    getTokensAmountOut(
      poolAmountIn: BigNumberish,
      minAmountsOut: BigNumberish[],
      overrides?: CallOverrides,
    ): Promise<PopulatedTransaction>;

    liquidate(
      liquidatedUser: string,
      tokenOut: string,
      poolAmountIn: BigNumberish,
      minAmountOut: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    protocolFee(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    DictatorDAO(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    smartPool(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    foldToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    treasury(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    withdraw(
      tokenOut: string,
      poolAmountIn: BigNumberish,
      minAmountOut: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    withdrawAll(
      poolAmountIn: BigNumberish,
      minAmountsOut: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    wrappingContract(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}
